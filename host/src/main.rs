// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{
    BITVMX_ELF, BITVMX_ID
};
use risc0_zkvm::{default_prover, get_prover_server, seal_to_json, ExecutorEnv, Groth16ReceiptVerifierParameters, ProverOpts, Receipt};
use risc0_groth16::{Seal, Verifier};


pub fn serialize_receipt(receipt: Receipt, name: &str) {
    //serialize with bincode
    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    //save to file
    let path = std::path::Path::new(name);
    std::fs::write(path, receipt_bytes).unwrap();
}

pub fn deserialize_receipt(name: &str) -> Receipt {

    //deserialize receipt from file using bin code
    let path = std::path::Path::new(name);
    let receipt_bytes = std::fs::read(path).unwrap();
    let receipt: Receipt = bincode::deserialize(&receipt_bytes).unwrap();
    receipt

}



pub fn prove_stark() {

    // An executor environment describes the configurations for the zkVM
    // including program inputs.
    // An default ExecutorEnv can be created like so:
    // `let env = ExecutorEnv::builder().build().unwrap();`
    // However, this `env` does not have any inputs.
    //
    // To add guest input to the executor environment, use
    // ExecutorEnvBuilder::write().
    // To access this method, you'll need to use ExecutorEnv::builder(), which
    // creates an ExecutorEnvBuilder. When you're done adding input, call
    // ExecutorEnvBuilder::build().

    // For example:
    //let input: u32 = 15 * u32::pow(2, 27) + 1;
    let input: u32 = 2;
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, BITVMX_ELF)
        .unwrap();

    // extract the receipt.
    let receipt = prove_info.receipt;

    println!("Receipt: {:?}", receipt);

    serialize_receipt(receipt, "receipt_stark.bin");


}


pub fn prove_snark() {

    let receipt = deserialize_receipt("receipt_stark.bin");

    let groth16_receipt = get_prover_server(&ProverOpts::groth16())
        .unwrap()
        .compress(&ProverOpts::groth16(), &receipt)
        .unwrap();
    //exec_verify(&groth16_receipt);
    println!("groth16_receipt: {:?}", groth16_receipt);
    //println!("groth16_receipt2: {:?}", groth16_receipt.inner.groth16().unwrap());

    let inner = groth16_receipt.inner.groth16().unwrap();
    println!("Verif params: {:?}", &inner.verifier_parameters);
    println!("Default: {:?}", Groth16ReceiptVerifierParameters::default());

    //let verifier_parameters_digest = Groth16ReceiptVerifierParameters::default().digest();

    let seal = &inner.seal;
    let sealed = Seal::from_vec(seal).unwrap();

    println!("sealed: {:?}", &sealed);

    //let verifier = Verifier::new()
    //groth16_receipt.verify(BITVMX_ID).unwrap();

    println!("{:?}", BITVMX_ID);


    serialize_receipt(groth16_receipt, "receipt_snark.bin");

    /*let path_str = "./output.json";
    let path = std::path::Path::new(path_str);
    let mut seal_json = Vec::new();
    seal_to_json(&sealed, &mut seal_json).unwrap();
    std::fs::write(path, seal_json).unwrap();*/


    //seal_to_json(groth16_receipt, writer)


    // Add code to generate a groth16 proof here.


    // TODO: Implement code for retrieving receipt journal here.

    // For example:
    //let _output: u32 = receipt.journal.decode().unwrap();

    // The receipt was verified at the end of proving, but the below code is an
    // example of how someone else could verify this receipt.
    //receipt
    //    .verify(BITVMX_ID)
    //    .unwrap();

}




fn main() {

    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    //read args
    let args: Vec<String> = std::env::args().collect();
    
    if args.len() < 2 {
        println!("Error in usage");
        std::process::exit(1);
    }

    if args[1] == "stark" {
        prove_stark();
        return;
    }

    if args[1] == "snark" {
        prove_snark();
        return;
    }


}
