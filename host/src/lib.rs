// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use cli_serde::load_elf;
use json::JsonValue;

use risc0_zkvm::sha::Digest;
use risc0_zkvm::{default_prover, get_prover_server, ExecutorEnv, ProverOpts, Receipt};

pub fn serialize_receipt(receipt: Receipt, name: &str) {
    //serialize with bincode
    let receipt_bytes = bincode::serialize(&receipt).unwrap();
    //save to file
    let path = std::path::Path::new(name);
    std::fs::write(path, receipt_bytes).unwrap();
}

pub fn deserialize_receipt(name: &str) -> Receipt {
    //deserialize receipt from file using bin code
    let path = std::path::Path::new(name);
    let receipt_bytes = std::fs::read(path).unwrap();
    let receipt: Receipt = bincode::deserialize(&receipt_bytes).unwrap();
    receipt
}

pub fn prove_stark(input: &str, elf_path: &str, output_file: &str) {
    let input_parsed = std::fs::read(input).unwrap();
    let start = std::time::Instant::now();

    let env = ExecutorEnv::builder()
        .write(&input_parsed)
        .unwrap()
        .build()
        .unwrap();

    // Obtain the default prover.
    let prover = default_prover();

    let elf = load_elf(elf_path).unwrap();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the code
    let prove_info = prover.prove(env, &*elf).unwrap();

    let duration = start.elapsed();

    // extract the receipt.
    let receipt = prove_info.receipt;

    println!(
        "The proof was executed, and the receipt saved to the file: {}. Total time: {:?}",
        output_file, duration
    );

    serialize_receipt(receipt, output_file);
}

pub fn verify_stark(image_id: impl Into<Digest>, receipt_fname: &str) {
    let receipt = deserialize_receipt(receipt_fname);
    receipt.verify(image_id).unwrap();
    println!("Receipt verified successfully");
}

pub fn prove_snark(receipt_fname: &str, output_groth_seal: &str) {
    let receipt = deserialize_receipt(receipt_fname);

    let groth16_receipt = get_prover_server(&ProverOpts::groth16())
        .unwrap()
        .compress(&ProverOpts::groth16(), &receipt)
        .unwrap();

    let mut json = JsonValue::new_array();
    for data in &groth16_receipt.inner.groth16().unwrap().seal {
        json.push(*data).unwrap();
    }

    let path = std::path::Path::new(output_groth_seal);
    std::fs::write(path, json.dump()).unwrap();

    println!(
        "The proof was executed, and the seal was saved to the file: {}",
        output_groth_seal
    );
}
