// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{BITVMX_ELF, BITVMX_ID};
use risc0_zkvm::{default_prover, get_prover_server, ExecutorEnv, ProverOpts, Receipt};

pub fn serialize_receipt(receipt: Receipt, name: &str) -> Result<(), String> {
    //serialize with bincode
    let receipt_bytes = bincode::serialize(&receipt).map_err(|_| "Failed to serialize receipt")?;
    //save to file
    let path = std::path::Path::new(name);
    std::fs::write(path, receipt_bytes)
        .map_err(|_| format!("Failed to write receipt to file: {}", name))?;

    Ok(())
}

pub fn deserialize_receipt(name: &str) -> Receipt {
    //deserialize receipt from file using bin code
    let path = std::path::Path::new(name);
    let receipt_bytes = std::fs::read(path).unwrap();
    let receipt: Receipt = bincode::deserialize(&receipt_bytes).unwrap();
    receipt
}

pub fn prove_stark(input: u32, output_file: &str) -> Result<(), String> {
    // Initialize the executor environment with the input.
    let env = ExecutorEnv::builder()
        .write(&input)
        .map_err(|e| format!("Failed to write input: {}", e))?
        .build()
        .map_err(|e| format!("Failed to build environment: {}", e))?;

    // Obtain the default prover.
    let prover = default_prover();

    // Proof information by proving the specified ELF binary.
    // This struct contains the receipt along with statistics about execution of the guest
    let prove_info = prover
        .prove(env, BITVMX_ELF)
        .map_err(|e| format!("Failed to prove: {}", e))?;

    // extract the receipt.
    let receipt = prove_info.receipt;

    serialize_receipt(receipt, output_file)?;

    println!(
        "The proof was executed, and the receipt saved to the file: {}",
        output_file
    );

    Ok(())
}

pub fn verify_stark(receipt_fname: &str) {
    let receipt = deserialize_receipt(receipt_fname);
    receipt.verify(BITVMX_ID).unwrap();
    println!("Receipt verified successfully");
}

pub fn prove_snark(receipt_name: &str) -> Result<Vec<u8>, String> {
    let receipt = deserialize_receipt(receipt_name);

    let groth16_receipt = get_prover_server(&ProverOpts::groth16())
        .map_err(|e| format!("Failed to get prover server: {}", e))?
        .compress(&ProverOpts::groth16(), &receipt)
        .map_err(|e| format!("Failed to compress receipt: {}", e))?;

    let mut data_vec = Vec::new();
    for data in &groth16_receipt
        .inner
        .groth16()
        .map_err(|e| format!("Failed to get groth16 data: {}", e))?
        .seal
    {
        data_vec.push(*data);
    }

    Ok(data_vec)
}
